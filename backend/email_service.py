"""
Email service for outreach generation and sending
"""

import os
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from typing import Optional, List
from dotenv import load_dotenv
from loguru import logger

from .models import Job, AgentMatch, Outreach
from .database import SessionLocal

load_dotenv()


class EmailService:
    def __init__(self):
        self.smtp_server = os.getenv("SMTP_SERVER", "smtp.gmail.com")
        self.smtp_port = int(os.getenv("SMTP_PORT", "587"))
        self.email_username = os.getenv("EMAIL_USERNAME")
        self.email_password = os.getenv("EMAIL_PASSWORD")
        self.from_email = os.getenv("FROM_EMAIL")
        self.from_name = os.getenv("FROM_NAME", "Tellen AI Workforce")

    def generate_outreach_email(self, job: Job, agent_match: AgentMatch) -> str:
        """Generate personalized outreach email for a job"""

        # Calculate Tellen service cost (20% of job salary)
        tellen_cost = int((job.salary_min + job.salary_max) / 2 * 0.2)

        # Determine agent description
        agent_descriptions = {
            "AFC": "Accounting & Financial Compliance agent",
            "FSP": "Financial Services Professional agent",
            "other": "specialized AI workforce agent",
        }

        agent_desc = agent_descriptions.get(agent_match.matched_agent, "AI workforce agent")

        # Generate email template
        email_template = f"""
Subject: AI Workforce Solution for {job.title} Position at {job.company}

Dear Hiring Manager,

I hope this email finds you well. I'm reaching out regarding your {job.title} position at {job.company} in {job.location}.

I represent Tellen, a leading provider of AI workforce solutions for accounting and financial services firms. After analyzing your job posting, I believe we have an ideal solution that could significantly reduce your hiring costs while maintaining high-quality work output.

**Our Solution:**
Our {agent_desc} is specifically designed to handle the core responsibilities outlined in your job posting:
- {self._extract_key_tasks(job.description)}
- Automated compliance and reporting
- 24/7 availability with consistent quality

**Cost Savings:**
Instead of the ${job.salary_min:,} - ${job.salary_max:,} annual salary for this position, our AI workforce solution costs approximately ${tellen_cost:,} annually - representing a potential savings of 80% while maintaining professional standards.

**Why Choose Tellen:**
- Proven track record with accounting firms
- Seamless integration with existing systems
- Dedicated support and training
- Scalable solutions that grow with your business
- No benefits, vacation, or overhead costs

**Next Steps:**
I'd love to schedule a brief 15-minute call to discuss how our AI workforce can specifically address your needs for the {job.title} role. We can also provide a customized demonstration of our capabilities.

Would you be available for a call this week? I'm flexible with timing and can work around your schedule.

Thank you for your time and consideration. I look forward to hearing from you.

Best regards,
{self.from_name}
Tellen AI Workforce Solutions

P.S. We're currently offering a 30-day free trial for qualified firms. This would allow you to experience the quality and efficiency of our AI workforce with no risk.

---
This email was generated by our AI system that analyzes job postings to identify automation opportunities. 
If you'd prefer not to receive these communications, please reply with "UNSUBSCRIBE" and we'll remove you from our outreach list.
"""

        return email_template.strip()

    def _extract_key_tasks(self, description: str) -> str:
        """Extract key tasks from job description"""
        # Simple keyword extraction - in a real system, this would use NLP
        keywords = []
        description_lower = description.lower()

        if "audit" in description_lower:
            keywords.append("Financial auditing and compliance")
        if "analysis" in description_lower:
            keywords.append("Financial analysis and reporting")
        if "accounting" in description_lower:
            keywords.append("Accounting operations and bookkeeping")
        if "reporting" in description_lower:
            keywords.append("Financial reporting and documentation")
        if "compliance" in description_lower:
            keywords.append("Regulatory compliance monitoring")

        if not keywords:
            keywords = ["Financial data processing and analysis"]

        return " â€¢ ".join(keywords[:3])  # Limit to 3 key tasks

    def save_outreach_draft(self, job_id: int, email_content: str, firm_contact: Optional[str] = None) -> int:
        """Save outreach email draft to database"""
        db = SessionLocal()
        try:
            outreach = Outreach(job_id=job_id, draft_email=email_content, status="draft", firm_contact=firm_contact)
            db.add(outreach)
            db.commit()
            db.refresh(outreach)
            return outreach.id
        except Exception as e:
            db.rollback()
            logger.error(f"Error saving outreach draft: {e}")
            raise
        finally:
            db.close()

    def send_email(self, to_email: str, subject: str, body: str) -> bool:
        """Send email using SMTP"""
        if not all([self.email_username, self.email_password, self.from_email]):
            logger.warning("Email credentials not configured. Email not sent.")
            return False

        try:
            msg = MIMEMultipart()
            msg["From"] = f"{self.from_name} <{self.from_email}>"
            msg["To"] = to_email
            msg["Subject"] = subject

            msg.attach(MIMEText(body, "plain"))

            server = smtplib.SMTP(self.smtp_server, self.smtp_port)
            server.starttls()
            server.login(self.email_username, self.email_password)
            text = msg.as_string()
            server.sendmail(self.from_email, to_email, text)
            server.quit()

            logger.info(f"Email sent successfully to {to_email}")
            return True

        except Exception as e:
            logger.error(f"Error sending email to {to_email}: {e}")
            return False

    def generate_outreach_for_job(self, job_id: int, firm_contact: Optional[str] = None) -> int:
        """Generate and save outreach email for a specific job"""
        db = SessionLocal()
        try:
            # Get job and its best agent match
            job = db.query(Job).filter(Job.id == job_id).first()
            if not job:
                raise ValueError(f"Job with ID {job_id} not found")

            agent_match = (
                db.query(AgentMatch).filter(AgentMatch.job_id == job_id).order_by(AgentMatch.confidence_score.desc()).first()
            )

            if not agent_match:
                raise ValueError(f"No agent match found for job {job_id}")

            # Generate email content
            email_content = self.generate_outreach_email(job, agent_match)

            # Save as draft
            outreach_id = self.save_outreach_draft(job_id, email_content, firm_contact)

            logger.info(f"Generated outreach email for job {job_id} (outreach ID: {outreach_id})")
            return outreach_id

        except Exception as e:
            logger.error(f"Error generating outreach for job {job_id}: {e}")
            raise
        finally:
            db.close()

    def send_approved_outreach(self, outreach_id: int) -> bool:
        """Send an approved outreach email"""
        db = SessionLocal()
        try:
            outreach = db.query(Outreach).filter(Outreach.id == outreach_id).first()
            if not outreach:
                raise ValueError(f"Outreach with ID {outreach_id} not found")

            if outreach.status != "approved":
                raise ValueError(f"Outreach {outreach_id} is not approved for sending")

            if not outreach.firm_contact:
                raise ValueError(f"No contact email for outreach {outreach_id}")

            # Extract subject and body from email content
            lines = outreach.draft_email.split("\n")
            subject = ""
            body_start = 0

            for i, line in enumerate(lines):
                if line.startswith("Subject:"):
                    subject = line.replace("Subject:", "").strip()
                    body_start = i + 2  # Skip subject line and empty line
                    break

            body = "\n".join(lines[body_start:])

            # Send email
            success = self.send_email(outreach.firm_contact, subject, body)

            if success:
                outreach.status = "sent"
                db.commit()
                logger.info(f"Outreach {outreach_id} sent successfully")

            return success

        except Exception as e:
            logger.error(f"Error sending outreach {outreach_id}: {e}")
            return False
        finally:
            db.close()


def generate_outreach_for_all_high_confidence_jobs(min_confidence: float = 0.8) -> List[int]:
    """Generate outreach emails for all jobs with high confidence agent matches"""
    db = SessionLocal()
    email_service = EmailService()
    generated_outreach_ids = []

    try:
        # Get jobs with high confidence matches
        high_confidence_matches = db.query(AgentMatch).filter(AgentMatch.confidence_score >= min_confidence).all()

        for match in high_confidence_matches:
            # Check if outreach already exists for this job
            existing_outreach = db.query(Outreach).filter(Outreach.job_id == match.job_id).first()

            if not existing_outreach:
                try:
                    outreach_id = email_service.generate_outreach_for_job(match.job_id)
                    generated_outreach_ids.append(outreach_id)
                except Exception as e:
                    logger.error(f"Failed to generate outreach for job {match.job_id}: {e}")

        logger.info(f"Generated {len(generated_outreach_ids)} outreach emails")
        return generated_outreach_ids

    except Exception as e:
        logger.error(f"Error generating outreach emails: {e}")
        return []
    finally:
        db.close()


if __name__ == "__main__":
    # Generate outreach emails for high confidence matches
    outreach_ids = generate_outreach_for_all_high_confidence_jobs()
    print(f"Generated {len(outreach_ids)} outreach emails: {outreach_ids}")
